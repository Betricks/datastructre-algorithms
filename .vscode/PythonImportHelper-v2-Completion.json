[
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": "sorting_algorithm.quick_sort",
        "description": "sorting_algorithm.quick_sort",
        "peekOfCode": "def quicksort(array):\n    if len(array) < 2:\n        return array\n    else:\n        pivot = array[0]\n        less = [i for i in array[1:] if i <= pivot] \n        greater = [i for i in array[1:] if i > pivot] \n        return quicksort(less) + [pivot] + quicksort(greater)\nprint(quicksort([10, 5, 2, 3]))\n# FUNCTION quickSort PRAMETER = LIST OF NUMBERS",
        "detail": "sorting_algorithm.quick_sort",
        "documentation": {}
    },
    {
        "label": "quck_sort",
        "kind": 2,
        "importPath": "sorting_algorithm.quick_sort",
        "description": "sorting_algorithm.quick_sort",
        "peekOfCode": "def quck_sort(nums: list[int]) -> list[int]:\n    \"\"\" My implementation of quck_sort algorithms.\n        if used psaudocode to write this algorithm of my own\n        but still it does'nt solve any or sort the array\n    \"\"\"\n    first: int = 0\n    last: int = len(nums) -1\n    pivot: int = first + last // 2\n    if len(nums) < 2:\n        return nums",
        "detail": "sorting_algorithm.quick_sort",
        "documentation": {}
    },
    {
        "label": "search_smallest",
        "kind": 2,
        "importPath": "sorting_algorithm.selection_sort",
        "description": "sorting_algorithm.selection_sort",
        "peekOfCode": "def search_smallest(lists: list[int]) -> int:\n    smallest: int = lists[0]\n    for i in range(len(lists)):\n        if lists[i] < smallest:\n            smallest = lists[i]\n    return smallest\ndef selection_sort(lists: list[int]) -> list[int]:\n    new_list: list[int] = []\n    for i in range(len(lists)):",
        "detail": "sorting_algorithm.selection_sort",
        "documentation": {}
    },
    {
        "label": "selection_sort",
        "kind": 2,
        "importPath": "sorting_algorithm.selection_sort",
        "description": "sorting_algorithm.selection_sort",
        "peekOfCode": "def selection_sort(lists: list[int]) -> list[int]:\n    new_list: list[int] = []\n    for i in range(len(lists)):\n        smallest: int = search_smallest(lists)\n        new_list.append(lists.pop(smallest))\n    return new_list\nprint(selection_sort([5,28,12,90,1,33,4,16,9,32,10]))",
        "detail": "sorting_algorithm.selection_sort",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "tree.bfs",
        "description": "tree.bfs",
        "peekOfCode": "class TreeNode:\n    def __init__(self, values: Any) -> None:\n        self.left: TreeNode = None\n        self.data: Any = values\n        self.right: TreeNode = None\nclass Tree:\n    def __init__(self) -> None:\n        self.root: TreeNode = None\n    def insert(self, data: Any) -> None:\n        if self.root == None:",
        "detail": "tree.bfs",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "tree.bfs",
        "description": "tree.bfs",
        "peekOfCode": "class Tree:\n    def __init__(self) -> None:\n        self.root: TreeNode = None\n    def insert(self, data: Any) -> None:\n        if self.root == None:\n            Node: TreeNode = TreeNode(data)\n            self.root = Node\n            print('inserted in root side')\n        else:\n            return self._insert(self.root, data)",
        "detail": "tree.bfs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tree.bfs",
        "description": "tree.bfs",
        "peekOfCode": "def main() -> None:\n    tree: Tree = Tree()\n    tree.insert(12)\n    tree.insert(1)\n    tree.insert(14)\n    tree.insert(19)\n    print(help(queue))\n    print(dir(queue))\nif __name__ == \"__main__\":\n    main()",
        "detail": "tree.bfs",
        "documentation": {}
    }
]